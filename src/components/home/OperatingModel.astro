---
import { t } from '@/i18n';
import type { Lang } from '@/i18n/config';

interface Node {
  id: string;
  label: { [key: string]: string } | string;
  x: number;
  y: number;
  color: string;
}

interface Edge {
  from: string;
  to: string;
  curve?: boolean;
}

interface Props {
  lang: Lang;
  model: {
    nodes: Node[];
    edges: Edge[];
  };
}

const { lang, model } = Astro.props;
const { nodes, edges } = model;

// Helper to get localized string
const getStr = (obj: any) => (typeof obj === 'string' ? obj : obj[lang]);

// Visual hierarchy with distinct node sizes
const primaryRadius = 56;   // Decisions - focal point
const secondaryRadius = 44; // Processing, Outputs - important nodes
const tertiaryRadius = 40;  // Inputs, Learning - supporting nodes

function getNodeRadius(node: Node) {
  if (node.id === 'decisions') return primaryRadius;
  if (node.id === 'processing' || node.id === 'outputs') return secondaryRadius;
  return tertiaryRadius;
}

// Helper to calculate point on circle circumference
// Calculates where a line from 'from' to 'to' intersects the circle at 'to'
function getPerimeterPoint(from: {x: number, y: number}, to: {x: number, y: number}, radius: number, offset: number = 5) {
  const dx = to.x - from.x;
  const dy = to.y - from.y;
  const angle = Math.atan2(dy, dx);

  return {
    x: to.x - (radius + offset) * Math.cos(angle),
    y: to.y - (radius + offset) * Math.sin(angle)
  };
}

// Helper to get start point on circle perimeter (opposite direction)
function getStartPoint(from: {x: number, y: number}, to: {x: number, y: number}, radius: number, offset: number = 5) {
  const dx = to.x - from.x;
  const dy = to.y - from.y;
  const angle = Math.atan2(dy, dx);

  return {
    x: from.x + (radius + offset) * Math.cos(angle),
    y: from.y + (radius + offset) * Math.sin(angle)
  };
}
---

<section class="section" id="operating-model">
  <div class="container">
    <div class="text-center mb-12">
      <h2 id="operating-model-title" class="text-3xl md:text-4xl font-bold text-foreground mb-3 reveal-element opacity-0 translate-y-4 transition-all">
        {t(lang, 'operatingModel.title')}
      </h2>
      <p class="text-sm text-muted max-w-2xl mx-auto reveal-element opacity-0 translate-y-4 transition-all delay-75">
        {t(lang, 'operatingModel.lead')}
      </p>
      <p id="operating-model-desc" class="text-lg text-muted max-w-2xl mx-auto reveal-element opacity-0 translate-y-4 transition-all delay-100">
        {t(lang, 'operatingModel.subtitle')}
      </p>
    </div>

    <!-- SVG Diagram -->
    <div class="operating-model-card w-full max-w-5xl mx-auto aspect-[3/1] md:aspect-[10/3] border border-border rounded-xl p-6 md:p-8 reveal-element opacity-0 translate-y-8 transition-all delay-200">
      <svg viewBox="0 0 1000 300" class="w-full h-full" role="img" aria-labelledby="operating-model-diagram-title operating-model-diagram-desc">
        <title id="operating-model-diagram-title">{t(lang, 'operatingModel.diagramTitle')}</title>
        <desc id="operating-model-diagram-desc">{t(lang, 'operatingModel.diagramDesc')}</desc>
        <defs>
          <!-- Enhanced gradient for main flow -->
          <linearGradient id="edge-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" stop-color="var(--color-accent)" stop-opacity="0.3" />
            <stop offset="50%" stop-color="var(--color-accent)" stop-opacity="0.7" />
            <stop offset="100%" stop-color="var(--color-accent)" stop-opacity="1" />
          </linearGradient>

          <!-- Gradient for learning loop - using accent with reduced opacity for cohesion -->
          <linearGradient id="loop-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" stop-color="var(--color-accent)" stop-opacity="0.4" />
            <stop offset="50%" stop-color="var(--color-accent)" stop-opacity="0.3" />
            <stop offset="100%" stop-color="var(--color-accent)" stop-opacity="0.25" />
          </linearGradient>

          <!-- Node gradients -->
          <linearGradient id="node-gradient-primary" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stop-color="var(--color-accent)" />
            <stop offset="100%" stop-color="var(--color-accent-dark)" />
          </linearGradient>

          <linearGradient id="node-gradient-secondary" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stop-color="var(--color-background)" />
            <stop offset="100%" stop-color="var(--color-surface)" />
          </linearGradient>

          <!-- Enhanced arrowheads -->
          <marker id="arrowhead" markerWidth="14" markerHeight="12" refX="13" refY="6" orient="auto" markerUnits="strokeWidth">
            <polygon points="0 0, 14 6, 0 12" fill="var(--color-accent)" />
          </marker>
          <!-- Loop arrow -->
          <marker id="arrowhead-loop" markerWidth="14" markerHeight="12" refX="13" refY="6" orient="auto" markerUnits="strokeWidth">
            <polygon points="0 0, 14 6, 0 12" fill="var(--color-accent)" opacity="0.55" />
          </marker>

          <!-- Glow filter for primary node -->
          <filter id="glow">
            <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
            <feMerge>
              <feMergeNode in="coloredBlur"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>

          <!-- Pulse halo for decisions -->
          <filter id="pulse-glow" x="-50%" y="-50%" width="200%" height="200%">
            <feGaussianBlur stdDeviation="6" result="pulseBlur"/>
            <feMerge>
              <feMergeNode in="pulseBlur"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>

          <!-- Soft halo for learning label -->
          <filter id="label-glow">
            <feGaussianBlur stdDeviation="1.6" result="blur"/>
            <feMerge>
              <feMergeNode in="blur"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>
        </defs>

        {(() => {
          const inputsNode = nodes.find((node) => node.id === 'inputs');
          if (!inputsNode) return null;
          const baseRadius = getNodeRadius(inputsNode) + 10;
          const orbitParticles = [
            { rx: 8, ry: -4, dur: '5.6s', delay: '0s', opacity: 0.65, size: 2.2 },
            { rx: 14, ry: 2, dur: '6.8s', delay: '1.2s', opacity: 0.5, size: 1.9 },
            { rx: 4, ry: 10, dur: '7.6s', delay: '2.1s', opacity: 0.4, size: 1.6 },
            { rx: 18, ry: 6, dur: '6.2s', delay: '0.6s', opacity: 0.55, size: 2.0 },
            { rx: 12, ry: -8, dur: '7.1s', delay: '1.8s', opacity: 0.45, size: 1.8 }
          ];

          return (
            <g class="input-orbit">
              {orbitParticles.map((particle, i) => {
                const rx = Math.max(10, baseRadius + particle.rx);
                const ry = Math.max(10, baseRadius + particle.ry);
                const pathId = `input-orbit-path-${i}`;
                const d = `M ${inputsNode.x + rx} ${inputsNode.y} A ${rx} ${ry} 0 1 0 ${inputsNode.x - rx} ${inputsNode.y} A ${rx} ${ry} 0 1 0 ${inputsNode.x + rx} ${inputsNode.y}`;

                return (
                  <g>
                    <path id={pathId} d={d} class="orbit-path" />
                    <circle
                      r={particle.size}
                      class="orbit-particle"
                      fill="var(--color-accent)"
                      opacity={particle.opacity}
                    >
                      <animateMotion
                        dur={particle.dur}
                        repeatCount="indefinite"
                        begin={particle.delay}
                        calcMode="spline"
                        keyTimes="0;0.35;0.7;1"
                        keySplines="0.4 0 0.2 1;0.2 0 0.8 1;0.4 0 0.2 1"
                      >
                        <mpath href={`#${pathId}`} />
                      </animateMotion>
                      <animate
                        attributeName="opacity"
                        values={`${particle.opacity * 0.7};${particle.opacity};${particle.opacity * 0.6};${particle.opacity * 0.8}`}
                        keyTimes="0;0.4;0.7;1"
                        dur="2.4s"
                        repeatCount="indefinite"
                      />
                      <animate
                        attributeName="r"
                        values={`${particle.size};${particle.size + 0.6};${particle.size - 0.2};${particle.size}`}
                        keyTimes="0;0.5;0.8;1"
                        dur="3.2s"
                        repeatCount="indefinite"
                      />
                    </circle>
                  </g>
                );
              })}
            </g>
          );
        })()}

        <!-- Edges with Animated Particles -->
        {edges.map((edge, edgeIndex) => {
          const startNode = nodes.find(n => n.id === edge.from)!;
          const endNode = nodes.find(n => n.id === edge.to)!;
          const startRadius = getNodeRadius(startNode);
          const endRadius = getNodeRadius(endNode);
          const curveOffset = edge.curve ? 12 : 8;
          const strokeWidth = edge.curve ? 2 : 2.5;

          // Calculate edge start and end points on circle perimeters
          const start = getStartPoint(startNode, endNode, startRadius, curveOffset);
          const end = getPerimeterPoint(startNode, endNode, endRadius, curveOffset);
          let curveStart = start;
          let curveEnd = end;
          if (edge.curve) {
            if (startNode.id === 'decisions') {
              curveStart = {
                x: startNode.x,
                y: startNode.y + startRadius + curveOffset
              };
            }
            if (endNode.id === 'processing') {
              curveEnd = {
                x: endNode.x,
                y: endNode.y + endRadius + curveOffset
              };
            }
          }

          // Particle configuration
          const particleCount = 3; // 3 particles per edge
          const particleDuration = edge.curve ? '4.4s' : '3s'; // Slower for curves
          const particleRadius = edge.curve ? 2.4 : 3;

          if (edge.curve) {
             const dx = curveEnd.x - curveStart.x;
             const absDx = Math.abs(dx);
             const learningNode = nodes.find((node) => node.id === 'learning');
             const loopTargetY = learningNode ? learningNode.y - 2 : Math.max(curveStart.y, curveEnd.y) + 80;
             const loopY = Math.min(220, Math.max(curveStart.y + 40, loopTargetY));
             const midX = (curveStart.x + curveEnd.x) / 2;
             const labelCenterShift = absDx * 0.06;
             const valleyX = midX + labelCenterShift;
             const drop = Math.max(30, Math.min(80, (loopY - curveStart.y) * 0.6));
             const flatHandle = Math.max(60, Math.min(150, absDx * 0.18));

             const c1 = { x: curveStart.x, y: curveStart.y + drop };
             const c2 = { x: valleyX - flatHandle, y: loopY };
             const c3 = { x: valleyX + flatHandle, y: loopY };
             const c4 = { x: curveEnd.x, y: curveEnd.y + drop };
             const pathD = `M ${curveStart.x} ${curveStart.y} C ${c1.x} ${c1.y} ${c2.x} ${c2.y} ${valleyX} ${loopY} C ${c3.x} ${c3.y} ${c4.x} ${c4.y} ${curveEnd.x} ${curveEnd.y}`;
             const pathId = `edge-path-${edgeIndex}`;

             return (
               <g>
                 <path
                   id={pathId}
                   d={pathD}
                   class="edge-loop fill-none"
                   stroke="url(#loop-gradient)"
                   stroke-width={strokeWidth}
                   stroke-dasharray="5 7"
                   stroke-linecap="round"
                   stroke-linejoin="round"
                   marker-end="url(#arrowhead-loop)"
                 />

                 {/* Flow particles for curved edge - using accent color for cohesion */}
                 {Array.from({ length: particleCount }).map((_, i) => (
                  <circle
                    r={particleRadius}
                    class="flow-particle flow-particle-loop"
                    fill="var(--color-accent)"
                    opacity="0"
                  >
                    <animateMotion
                      dur={particleDuration}
                      repeatCount="indefinite"
                      begin={`${i * (parseFloat(particleDuration) / particleCount)}s`}
                    >
                      <mpath href={`#${pathId}`} />
                    </animateMotion>
                    <animate
                      attributeName="opacity"
                      values="0;0.35;0.35;0"
                      keyTimes="0;0.1;0.9;1"
                      dur={particleDuration}
                      repeatCount="indefinite"
                      begin={`${i * (parseFloat(particleDuration) / particleCount)}s`}
                    />
                    <animate
                      attributeName="r"
                      values={`${particleRadius};${particleRadius + 0.6};${particleRadius}`}
                      keyTimes="0;0.5;1"
                      dur="2.8s"
                      repeatCount="indefinite"
                      begin={`${i * 0.4}s`}
                    />
                  </circle>
                ))}
              </g>
            );
          }

          const pathId = `edge-path-${edgeIndex}`;
          const pathD = `M ${start.x} ${start.y} L ${end.x} ${end.y}`;

          return (
            <g>
              <path
                id={pathId}
                d={pathD}
                class="edge-primary fill-none"
                stroke="url(#edge-gradient)"
                stroke-width={strokeWidth}
                marker-end="url(#arrowhead)"
              />

              {/* Flow particles for straight edge */}
              {Array.from({ length: particleCount }).map((_, i) => (
                <circle
                  r={particleRadius}
                  class="flow-particle"
                  fill="var(--color-accent)"
                  opacity="0"
                >
                  <animateMotion
                    dur={particleDuration}
                    repeatCount="indefinite"
                    begin={`${i * (parseFloat(particleDuration) / particleCount)}s`}
                  >
                    <mpath href={`#${pathId}`} />
                  </animateMotion>
                  <animate
                    attributeName="opacity"
                    values="0;0.8;0.8;0"
                    keyTimes="0;0.1;0.9;1"
                    dur={particleDuration}
                    repeatCount="indefinite"
                    begin={`${i * (parseFloat(particleDuration) / particleCount)}s`}
                  />
                </circle>
              ))}
            </g>
          );
        })}

        <!-- Nodes -->
        {nodes.map((node, i) => {
          const nodeRadius = getNodeRadius(node);
          const isPrimary = node.id === 'decisions';
          const isSecondary = node.id === 'processing' || node.id === 'outputs';
          const isTertiary = node.id === 'inputs' || node.id === 'learning';
          const isLearning = node.id === 'learning';
          const isInputs = node.id === 'inputs';
          const isDecisions = node.id === 'decisions';

          // Typography hierarchy
          const textSize = isPrimary ? 'text-base' : isSecondary ? 'text-sm' : 'text-sm';
          const textWeight = isPrimary ? 'font-bold' : isSecondary ? 'font-semibold' : 'font-medium';

          return (
          <g class="group node-group" style={`animation-delay: ${i * 0.5}s`}>
            {/* Outer ring for depth (only for primary and secondary) */}
            {(isPrimary || isSecondary) && (
              <circle
                cx={node.x}
                cy={node.y}
                r={nodeRadius + 3}
                class={`fill-none stroke-accent/20 stroke-1${isDecisions ? ' pulse-ring' : ''}`}
              />
            )}

            {/* Main node circle */}
            {!isLearning && (
              <circle
                cx={node.x}
                cy={node.y}
                r={nodeRadius}
                class={isPrimary
                  ? 'fill-accent stroke-accent-dark stroke-2 node-primary heartbeat-node'
                  : isSecondary
                    ? 'fill-surface stroke-accent stroke-2 node-secondary'
                    : isInputs
                      ? 'fill-accent/10 stroke-accent/40 stroke-2 node-tertiary'
                      : 'fill-background stroke-border stroke-2 node-tertiary'
                }
                style={isPrimary ? 'filter: url(#glow);' : ''}
              />
            )}

            {/* Node label with hierarchy */}
            <text
              x={node.x}
              y={node.y}
              dy={isLearning ? '-4' : '5'}
              dx={isLearning ? '-3' : '0'}
              text-anchor="middle"
              class={`${textSize} ${textWeight} pointer-events-none select-none ${isPrimary ? 'fill-background' : 'fill-foreground'}${isLearning ? ' opacity-85 tracking-[0.06em] uppercase' : ''}`}
              style={isLearning ? 'filter: url(#label-glow); font-size: 1.1em;' : ''}
            >
              {getStr(node.label)}
            </text>

            <!-- Tooltip -->
            <title>{getStr(node.label)}</title>
          </g>
        )})}
      </svg>
    </div>
  </div>
</section>

<script>
  /**
   * Operating Model Animation Controller
   * Handles reveal animations and flow particle motion with reduced-motion support
   */

  function prefersReducedMotion(): boolean {
    return window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  }

  function initOperatingModel() {
    const reduced = prefersReducedMotion();

    // Handle flow particle animations based on motion preference
    if (reduced) {
      // Disable flow particles for reduced motion
      document.querySelectorAll('#operating-model .flow-particle, #operating-model .orbit-particle').forEach((particle) => {
        (particle as SVGElement).style.display = 'none';
      });
    } else {
      // Ensure particles are visible
      document.querySelectorAll('#operating-model .flow-particle, #operating-model .orbit-particle').forEach((particle) => {
        (particle as SVGElement).style.display = 'block';
      });
    }

    // Reveal animation observer
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.remove('opacity-0', 'translate-y-4', 'translate-y-8');
          entry.target.classList.add('opacity-100', 'translate-y-0');
          observer.unobserve(entry.target);
        }
      });
    }, {
      threshold: 0.1,
      rootMargin: '50px'
    });

    document.querySelectorAll('#operating-model .reveal-element').forEach((el) => {
      observer.observe(el);
    });
  }

  // Initialize on load
  initOperatingModel();

  // Re-initialize on view transitions
  document.addEventListener('astro:page-load', initOperatingModel);
</script>

<style>
  /* Flow particle styles */
  .flow-particle {
    pointer-events: none;
    filter: blur(0.5px);
  }

  /* Loop particles with slightly more blur for depth differentiation */
  .flow-particle-loop {
    filter: blur(0.9px);
  }
  .orbit-path {
    fill: none;
    stroke: transparent;
  }
  .orbit-particle {
    pointer-events: none;
    filter: blur(0.6px);
  }

  /* Node animations and interactions */
  .node-group {
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .node-primary {
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }
  .heartbeat-node {
    transform-origin: center;
    animation: heartbeat 1.2s infinite;
  }
  .pulse-ring {
    animation: heartbeat-ring 1.2s infinite;
    filter: url(#pulse-glow);
  }

  .node-secondary {
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  }

  .node-tertiary {
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    opacity: 0.9;
  }

  /* Subtle hover effects */
  .node-group:hover .node-primary {
    filter: url(#glow) brightness(1.1);
  }

  .node-group:hover .node-secondary {
    stroke-width: 2.5;
  }

  .node-group:hover .node-tertiary {
    opacity: 1;
    stroke-width: 2.5;
  }

  /* Edge styles */
  .edge-primary {
    transition: stroke-width 0.3s ease;
  }

  .edge-loop {
    transition: stroke-width 0.3s ease;
    opacity: 0.75;
  }

  @keyframes heartbeat {
    0% { transform: scale(1); }
    12% { transform: scale(1.04); }
    20% { transform: scale(1); }
    30% { transform: scale(1.02); }
    40% { transform: scale(1); }
    100% { transform: scale(1); }
  }

  @keyframes heartbeat-ring {
    0% { opacity: 0.22; transform: scale(1); }
    12% { opacity: 0.45; transform: scale(1.05); }
    20% { opacity: 0.18; transform: scale(1.01); }
    30% { opacity: 0.35; transform: scale(1.03); }
    40% { opacity: 0.18; transform: scale(1); }
    100% { opacity: 0.22; transform: scale(1); }
  }

  /* Disable particle animations for reduced motion */
  @media (prefers-reduced-motion: reduce) {
    .flow-particle,
    .orbit-particle {
      display: none !important;
    }

    .node-group,
    .node-primary,
    .node-secondary,
    .node-tertiary,
    .edge-primary,
    .edge-loop {
      transition: none !important;
    }
    .heartbeat-node,
    .pulse-ring {
      animation: none !important;
      transform: none !important;
    }
  }
</style>
