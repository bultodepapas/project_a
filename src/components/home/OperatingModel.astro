---
import { t } from '@/i18n';
import type { Lang } from '@/i18n/config';

interface Node {
  id: string;
  label: { [key: string]: string } | string;
  x: number;
  y: number;
  color: string;
}

interface Edge {
  from: string;
  to: string;
  curve?: boolean;
}

interface Props {
  lang: Lang;
  model: {
    nodes: Node[];
    edges: Edge[];
  };
}

const { lang, model } = Astro.props;
const { nodes, edges } = model;

// Helper to get localized string
const getStr = (obj: any) => (typeof obj === 'string' ? obj : obj[lang]);

const baseRadius = 40;
const primaryRadius = 46;

function getNodeRadius(node: Node) {
  return node.id === 'decisions' ? primaryRadius : baseRadius;
}

// Helper to calculate point on circle circumference
function getPerimeterPoint(from: {x: number, y: number}, to: {x: number, y: number}, radius: number, offset: number = 5) {
  const dx = to.x - from.x;
  const dy = to.y - from.y;
  const angle = Math.atan2(dy, dx);
  
  return {
    x: to.x - (radius + offset) * Math.cos(angle),
    y: to.y - (radius + offset) * Math.sin(angle)
  };
}
---

<section class="section" id="operating-model">
  <div class="container">
    <div class="text-center mb-12">
      <h2 id="operating-model-title" class="text-3xl md:text-4xl font-bold text-foreground mb-3 reveal-element opacity-0 translate-y-4 transition-all">
        {t(lang, 'operatingModel.title')}
      </h2>
      <p class="text-sm text-muted max-w-2xl mx-auto reveal-element opacity-0 translate-y-4 transition-all delay-75">
        {t(lang, 'operatingModel.lead')}
      </p>
      <p id="operating-model-desc" class="text-lg text-muted max-w-2xl mx-auto reveal-element opacity-0 translate-y-4 transition-all delay-100">
        {t(lang, 'operatingModel.subtitle')}
      </p>
    </div>

    <!-- SVG Diagram -->
    <div class="w-full max-w-5xl mx-auto aspect-[3/1] md:aspect-[4/1] bg-surface border border-border rounded-xl p-6 md:p-8 shadow-md reveal-element opacity-0 translate-y-8 transition-all delay-200">
      <svg viewBox="0 0 800 200" class="w-full h-full" role="img" aria-labelledby="operating-model-diagram-title operating-model-diagram-desc">
        <title id="operating-model-diagram-title">{t(lang, 'operatingModel.diagramTitle')}</title>
        <desc id="operating-model-diagram-desc">{t(lang, 'operatingModel.diagramDesc')}</desc>
        <defs>
          <linearGradient id="edge-gradient" x1="0%" y1="0%" x2="100%" y2="0%">
            <stop offset="0%" stop-color="var(--color-border)" />
            <stop offset="100%" stop-color="var(--color-accent)" />
          </linearGradient>
          <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
            <polygon points="0 0, 10 3.5, 0 7" class="fill-accent" />
          </marker>
        </defs>

        <!-- Edges -->
        {edges.map((edge) => {
          const startNode = nodes.find(n => n.id === edge.from)!;
          const endNode = nodes.find(n => n.id === edge.to)!;
          const startRadius = getNodeRadius(startNode);
          const endRadius = getNodeRadius(endNode);
          
          // Calculate trimming
          const start = getPerimeterPoint(endNode, startNode, startRadius, 6);
          const end = getPerimeterPoint(startNode, endNode, endRadius, 6);

          if (edge.curve) {
             // Improve Feedback Loop Curve
             // If going back to inputs (Learning -> Inputs), curve DOWN/Left
             const isFeedback = startNode.y > 100 || endNode.y > 100;
             
             // Control point logic for nice swoop
             let cx, cy;
             if (isFeedback) {
                cx = (start.x + end.x) / 2;
                cy = Math.max(start.y, end.y) + 45; // Curve below
             } else {
                cx = (start.x + end.x) / 2;
                cy = (start.y + end.y) / 2 - 40; // Curve above
             }

             return (
               <path 
                 d={`M ${start.x} ${start.y} Q ${cx} ${cy} ${end.x} ${end.y}`}
                 class="edge-loop"
                 marker-end="url(#arrowhead)"
               />
             );
          }
          
          return (
            <line 
              x1={start.x} y1={start.y} 
              x2={end.x} y2={end.y} 
              class="edge-primary"
              marker-end="url(#arrowhead)"
            />
          );
        })}

        <!-- Nodes -->
        {nodes.map((node, i) => {
          const nodeRadius = getNodeRadius(node);
          const isLoop = node.id === 'learning';
          const nodeClass = isLoop ? 'node-loop' : 'node-core';

          return (
          <g class={`group animate-pulse-node ${nodeClass}`} style={`animation-delay: ${i * 0.5}s`}>
            <circle cx={node.x} cy={node.y} r={nodeRadius} class={`fill-background stroke-2 ${node.color} transition-all duration-300`} />
            <text x={node.x} y={node.y} dy="5" text-anchor="middle" class="text-xs md:text-sm font-medium fill-foreground pointer-events-none select-none">
              {getStr(node.label)}
            </text>
            
            <!-- Tooltip (SVG only) -->
            <title>{getStr(node.label)}</title>
          </g>
        )})}
      </svg>
    </div>
  </div>
</section>

<script>
  function initOperatingModel() {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.remove('opacity-0', 'translate-y-4', 'translate-y-8');
          entry.target.classList.add('opacity-100', 'translate-y-0');
          observer.unobserve(entry.target);
        }
      });
    }, {
      threshold: 0.1,
      rootMargin: '50px'
    });

    document.querySelectorAll('#operating-model .reveal-element').forEach((el) => {
      observer.observe(el);
    });
  }

  // Initialize on load
  initOperatingModel();

  // Re-initialize on view transitions
  document.addEventListener('astro:page-load', initOperatingModel);
</script>
